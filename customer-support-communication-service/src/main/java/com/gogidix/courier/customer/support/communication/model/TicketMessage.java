package com.gogidix.courier.customer.support.communication.model;

import com.gogidix.shared.model.BaseEntity;
import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Entity representing a message within a support ticket conversation.
 * 
 * This entity tracks all communications between customers and support agents
 * within a ticket, providing a complete conversation history.
 * 
 * @author Exalt Development Team
 * @since 1.0.0
 */
@Entity
@Table(name = "ticket_messages", indexes = {
    @Index(name = "idx_message_ticket_id", columnList = "ticket_id"),
    @Index(name = "idx_message_sender_id", columnList = "sender_id"),
    @Index(name = "idx_message_created_at", columnList = "created_at"),
    @Index(name = "idx_message_is_internal", columnList = "is_internal"),
    @Index(name = "idx_message_is_read", columnList = "is_read")
})
@Data
@EqualsAndHashCode(callSuper = true)
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TicketMessage extends BaseEntity {

    @NotNull(message = "Ticket is required")
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "ticket_id", nullable = false)
    private SupportTicket ticket;

    @NotBlank(message = "Sender ID is required")
    @Size(max = 50, message = "Sender ID must not exceed 50 characters")
    @Column(name = "sender_id", nullable = false, length = 50)
    private String senderId;

    @Size(max = 100, message = "Sender name must not exceed 100 characters")
    @Column(name = "sender_name", length = 100)
    private String senderName;

    @Email(message = "Sender email must be valid")
    @Size(max = 100, message = "Sender email must not exceed 100 characters")
    @Column(name = "sender_email", length = 100)
    private String senderEmail;

    @NotNull(message = "Sender type is required")
    @Enumerated(EnumType.STRING)
    @Column(name = "sender_type", nullable = false, length = 20)
    private SenderType senderType;

    @NotBlank(message = "Message content is required")
    @Size(max = 10000, message = "Message content must not exceed 10000 characters")
    @Column(name = "content", nullable = false, columnDefinition = "TEXT")
    private String content;

    @Enumerated(EnumType.STRING)
    @Column(name = "message_type", length = 20)
    private MessageType messageType;

    @Builder.Default
    @Column(name = "is_internal", nullable = false)
    private Boolean isInternal = false;

    @Builder.Default
    @Column(name = "is_read", nullable = false)
    private Boolean isRead = false;

    @Column(name = "read_at")
    private LocalDateTime readAt;

    @Size(max = 50, message = "Read by must not exceed 50 characters")
    @Column(name = "read_by", length = 50)
    private String readBy;

    @Builder.Default
    @Column(name = "is_auto_generated", nullable = false)
    private Boolean isAutoGenerated = false;

    @Size(max = 100, message = "Auto generation source must not exceed 100 characters")
    @Column(name = "auto_generation_source", length = 100)
    private String autoGenerationSource;

    @Column(name = "reply_to_message_id")
    private java.util.UUID replyToMessageId;

    @Size(max = 200, message = "Channel must not exceed 200 characters")
    @Column(name = "channel", length = 200)
    private String channel; // web, mobile, email, chat, phone

    @Column(name = "edited_at")
    private LocalDateTime editedAt;

    @Size(max = 50, message = "Edited by must not exceed 50 characters")
    @Column(name = "edited_by", length = 50)
    private String editedBy;

    @Size(max = 500, message = "Edit reason must not exceed 500 characters")
    @Column(name = "edit_reason", length = 500)
    private String editReason;

    @OneToMany(mappedBy = "message", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<MessageAttachment> attachments;

    /**
     * Enumeration for sender types.
     */
    public enum SenderType {
        CUSTOMER("Customer"),
        AGENT("Support Agent"),
        SYSTEM("System"),
        SUPERVISOR("Supervisor"),
        SPECIALIST("Specialist");

        private final String displayName;

        SenderType(String displayName) {
            this.displayName = displayName;
        }

        public String getDisplayName() {
            return displayName;
        }

        public boolean isStaff() {
            return this == AGENT || this == SUPERVISOR || this == SPECIALIST;
        }
    }

    /**
     * Enumeration for message types.
     */
    public enum MessageType {
        REPLY("Reply"),
        STATUS_UPDATE("Status Update"),
        ESCALATION("Escalation"),
        RESOLUTION("Resolution"),
        AUTO_RESPONSE("Auto Response"),
        SYSTEM_NOTE("System Note"),
        INTERNAL_NOTE("Internal Note"),
        FOLLOW_UP("Follow Up");

        private final String displayName;

        MessageType(String displayName) {
            this.displayName = displayName;
        }

        public String getDisplayName() {
            return displayName;
        }

        public boolean isVisibleToCustomer() {
            return this != INTERNAL_NOTE && this != SYSTEM_NOTE;
        }
    }

    // Business Logic Methods

    /**
     * Check if message is from customer.
     */
    public boolean isFromCustomer() {
        return senderType == SenderType.CUSTOMER;
    }

    /**
     * Check if message is from staff.
     */
    public boolean isFromStaff() {
        return senderType.isStaff();
    }

    /**
     * Check if message is visible to customer.
     */
    public boolean isVisibleToCustomer() {
        if (isInternal) {
            return false;
        }
        return messageType == null || messageType.isVisibleToCustomer();
    }

    /**
     * Check if message requires response.
     */
    public boolean requiresResponse() {
        return isFromCustomer() && 
               (messageType == null || messageType == MessageType.REPLY) &&
               !isAutoGenerated;
    }

    /**
     * Get message age in hours.
     */
    public long getAgeHours() {
        return java.time.Duration.between(getCreatedAt(), LocalDateTime.now()).toHours();
    }

    /**
     * Mark message as read.
     */
    public void markAsRead(String readerId) {
        this.isRead = true;
        this.readAt = LocalDateTime.now();
        this.readBy = readerId;
    }

    /**
     * Check if message is edited.
     */
    public boolean isEdited() {
        return editedAt != null;
    }

    /**
     * Generate message preview for notifications.
     */
    public String generatePreview(int maxLength) {
        if (content == null || content.trim().isEmpty()) {
            return "";
        }
        
        String preview = content.trim();
        if (preview.length() > maxLength) {
            return preview.substring(0, maxLength - 3) + "...";
        }
        return preview;
    }

    /**
     * Get message priority based on content and context.
     */
    public TicketPriority getInferredPriority() {
        if (content == null) {
            return TicketPriority.NORMAL;
        }
        
        return TicketPriority.determinePriorityFromContent(content);
    }
}